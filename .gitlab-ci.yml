image: docker:latest
variables:
  IMAGE_NAME: ${CI_REGISTRY}/${CI_PROJECT_PATH}
  
stages:          # List of stages for jobs, and their order of execution
  # - prebuild
  - build
  - vuln-scan
  - push

Construction:       # This job runs in the build stage, which runs first.
  stage: build
  before_script:
    - set
  script:
    # Build
    - docker image build -t ${IMAGE_NAME}:build-temp  .
    

Publication:
  stage: push
  script:
    - docker image tag      ${IMAGE_NAME}:build-temp  ${IMAGE_NAME}:${CI_COMMIT_TAG:-devel}
    # Login, push, et logout
    - echo ${CI_REGISTRY_PASSWORD} | docker login ${CI_REGISTRY} -u ${CI_REGISTRY_USER} --password-stdin
    - docker image push                               ${IMAGE_NAME}:${CI_COMMIT_TAG:-devel}
    - docker logout   
  after_script:
    # Nettoyage du runner (merci de laisser cet endroit aussi propre que vous l'avez trouvé en entrant...)
    - docker image rm       ${IMAGE_NAME}:build-temp  ${IMAGE_NAME}:${CI_COMMIT_TAG:-devel}

Scan de vulnerabilite:
  stage: vuln-scan
  script:

    - mkdir -p -m 2770 ${PWD}/scan-result

    - docker container run --rm \
             -v /var/run/docker.sock:/var/run/docker.sock \
             -v trivy-cache:/root/.cache/  \
             aquasec/trivy --cache-dir /root/.cache/  image --scanners vuln --no-progress  \
                   ${REGISTRY_URL}:${HTTPD_VERSION}-${TAG_PREFIX} | tee ${PWD}/scan-result/scan-${CI_PROJECT_NAME}.log

    - |
      grep -q "CRITICAL: [^0]" ${PWD}/scan-result/scan-${CI_PROJECT_NAME}.log && \
           if [ ${STOP_IF_VULNERABILITY_FOUND:-0} != 0 ] ; then echo "Vulnérabilité CRITICAL détectée, arrêt du pipeline" && exit 1 ; fi

  artifacts:
    when: always
    paths:
    - ${PWD}/scan-result
    expire_in: 1 week
    
# 
# Deploiement:
  # stage: deploy
  # script:
  # - echo "Un jour, on déploie l'application"
